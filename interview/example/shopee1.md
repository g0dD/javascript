#### 一面
写一个防抖。你现在写的是非立即执行的版本，可以再写一个立即执行的版本吗？

一道事件循环代码输出的题，并说出理由。

介绍一下跨域。

介绍一下预检请求

#### 二面

代码题：实现一个compose函数

大数相加
#### SON.parse(JSON.stringify(obj))有什么不足之处？当object内存在循环引用时会报错吗？
JSON.parse(JSON.stringify(obj))可以实现数组和对象和基本数据类型的深拷贝，但不能处理函数。因为JSON.stringify()方法是将一个javascript值转换我一个JSON字符串，不能接受函数。其他影响如下：

如果对象中有时间对象，那么用该方法拷贝之后的对象中，时间是字符串形式而不是时间对象
如果对象中有RegExp、Error对象，那么序列化的结果是空
如果对象中有函数或者undefined，那么序列化的结果会把函数或undefined丢失
如果对象中有NAN、infinity、-infinity，那么序列化的结果会变成null
JSON.stringfy()只能序列化对象的可枚举自有属性，如果对象中有是构造函数生成的，那么拷贝后会丢弃对象的constructor
如果对象中存在循环引用也无法正确实现深拷贝，会报错

#### es6 class和es5构造函数之间的区别与联系？
基本上，ES6的class可以看作只是一个语法糖，它的绝大部份功能，ES5都可以做到，新的class写法只是让对象原型的写法更加清晰、更加像面向对象编程的语法而已。class中有一个constructor()方法，这就是构造方法，而this关键字则代表实例对象。使用typeof可以发现，类的数据类型就是函数，类本身就指向构造函数，使用的时候，也是直接对类使用new命令，与构造函数的用法完全一致。构造函数的prototype属性，在es6的class上面继续存在。事实上，类的所有方法都定义在prototype属性上面。因此，在类的实例上面调用方法其实就是调用原型上的方法。由于类的方法都定义在prototype对象上面，所以类的新方法可以添加在prototype对象上面。Object.assign()方法可以很方便地一次向类添加多个方法。prototype对象的constructor()属性直接指向类本身，这与ES5的行为是一致的。但是，类的内部所有定义的方法，都是不可枚举的，这一点与ES5的行为不一致。类必须使用new调用，否则会报错，这是它跟普通构造函数的一个区别，后者不用new也可以执行。




[referer](https://juejin.cn/post/7017655711291146253)