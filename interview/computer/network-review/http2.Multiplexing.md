## Multiplexing 多路复用

#### Keep-Alive

- Keep-Alive 之前：
  浏览器请求//static.mtime.cn/a.js-->解析域名-->HTTP 连接-->服务器处理文件-->返回数据-->浏览器解析、渲染文件
  浏览器请求//static.mtime.cn/b.js-->解析域名-->HTTP 连接-->服务器处理文件-->返回数据-->浏览器解析、渲染文件
  ...
  每次请求都会建立一次 HTTP 连接，也就是我们常说的 3 次握手 4 次挥手，这个过程在一次请求过程中占用了相当长的时间，而且逻辑上是非必需的，因为不间断的请求数据，第一次建立连接是正常的，以后就占用这个通道，下载其他文件，这样效率多高啊！你猜对了，这就是 Keep-Alive
- Keep-Alive 解决的问题
  Keep-Alive 解决的核心问题：一定时间内，同一域名多次请求数据，只建立一次 HTTP 请求，其他请求可复用每一次建立的连接通道，以达到提高请求效率的问题。这里面所说的一定时间是可以配置的，不管你用的是 Apache 还是 nginx。

#### HTTP1.1 还是存在效率问题

如上面所说，在 HTTP1.1 中是默认开启了 Keep-Alive，他解决了多次连接的问题，但是依然有两个效率上的问题：

- 第一个：串行的文件传输。当请求 a 文件时，b 文件只能等待，等待 a 连接到服务器、服务器处理文件、服务器返回文件，这三个步骤。我们假设这三步用时都是 1 秒，那么 a 文件用时为 3 秒，b 文件传输完成用时为 6 秒，依此类推。（注：此项计算有一个前提条件，就是浏览器和服务器是单通道传输）
- 第二个：连接数过多。我们假设 Apache 设置了最大并发数为 300，因为浏览器限制，浏览器发起的最大请求数为 6，也就是服务器能承载的最高并发为 50，当第 51 个人访问时，就需要等待前面某个请求处理完成。

#### HTTP/2 的多路复用

[referfer](https://www.cnblogs.com/cangqinglang/p/11361638.html)
HTTP/2 的多路复用就是为了解决上述的两个性能问题

- 解决第一个：在 HTTP1.1 的协议中，我们传输的 request 和 response 都是基本于文本的，这样就会引发一个问题：所有的数据必须按顺序传输，比如需要传输：hello world，只能从 h 到 d 一个一个的传输，不能并行传输，因为接收端并不知道这些字符的顺序，所以并行传输在 HTTP1.1 是不能实现的。

HTTP/2 引入二进制数据帧和流的概念，其中帧对数据进行顺序标识，如下图所示，这样浏览器收到数据之后，就可以按照序列对数据进行合并，而不会出现合并后数据错乱的情况。同样是因为有了序列，服务器就可以并行的传输数据，这就是流所做的事情。

- 解决第二个问题：HTTP/2 对同一域名下所有请求都是基于流，也就是说同一域名不管访问多少文件，也只建立一路连接。同样 Apache 的最大连接数为 300，因为有了这个新特性，最大的并发就可以提升到 300，比原来提升了 6 倍！

#### 以前我们做的性能优化不适用于 HTTP/2 了

- JS 文件的合并。我们现在优化的一个主要方向就是尽量的减少 HTTP 的请求数， 对我们工程中的代码，研发时分模块开发，上线时我们会把所有的代码进行压缩合并，合并成一个文件，这样不管多少模块，都请求一个文件，减少了 HTTP 的请求数。但是这样做有一个非常严重的问题：文件的缓存。当我们有 100 个模块时，有一个模块改了东西，按照之前的方式，整个文件浏览器都需要重新下载，不能被缓存。现在我们有了 HTTP/2 了，模块就可以单独的压缩上线，而不影响其他没有修改的模块。
- 多域名提高浏览器的下载速度。之前我们有一个优化就是把 css 文件和 js 文件放到 2 个域名下面，这样浏览器就可以对这两个类型的文件进行同时下载，避免了浏览器 6 个通道的限制，这样做的缺点也是明显的，1.DNS 的解析时间会变长。2.增加了服务器的压力。有了 HTTP/2 之后，根据上面讲的原理，我们就不用这么搞了，成本会更低。
